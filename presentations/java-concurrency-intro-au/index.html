<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Java concurrency: why & how</title>
        <link href="impress.css" rel="stylesheet"/>
        <script src="jquery-1.8.2.min.js"></script>
        <script src="jmpress.impress.js"></script>
    </head>

    <body>
        <div id="impress" class="impress-not-supported">
            <div class="step slide" style="text-align: center">
                <h1>Куда текут абстракции многопоточности</h1>
                <h2>Или казалось бы, причём здесь Java</h2>
                <br/>
                <br/>
                <br/>
                <br/>
                <br/>
                <br/>
                <br/>
                <small>Глеб Смирнов, <a href="me@gvsmirnov.ru">me@gvsmirnov.ru</a></small>
            </div>

            <div class="step slide" data-x="1100">
                <h1>Disclaimer: <small style="font-size: 30px">на самом деле, всё не так</small></h2>
                <p>
                    Изложенный на данном семинаре материал является общим и поверхностным описанием того, как и почему работает многопоточность.
                    Во многих реальных случаях происходящее может отличаться от описанного здесь. Многие из теоретических аспектов также опущены или упрощены.
                </p>
            </div>

            <div class="step" data-x="2200" data-y="-800">
                <h2>Just another brick in the <strong>memory wall</strong></h2>
                <ul>
                    <li>Скорость доступа к RAM растёт в ~1000 раз медленнее, чем скорость CPU</li>
                    <li>Нужно расположить данные ближе к ядрам! Многоуровневые кеши &dash; панацея!</li>
                </ul>
            </div>

            <div class="step" data-x="2200">
                <h1>Moore's law</h1>
                <p>Число транзисторов, умещающихся на интегральной схеме, удваивается каждые два года</p>
            </div>

            <div class="step" data-x="2200" data-y="800">
                <img width="700" src="img/moore-graph-annotated.png" />
            </div>

            <div class="step" data-x="3300">
                <h1>Частота процессоров почти не растёт</h1>
                <p>
                    За последние 5-10 лет практически не увеличилась частота процессора, поскольку возникли физические ограничения.
                </p>
            </div>

            <div class="step" data-x="3300" data-y="800" data-jmpress="fade">
                <h2>Частота vs размер</h2>
                <p>
                    <ul>
                        <li>transistor gate и так толщиной в молекулу</li>
                        <li>Провода, соединяющие транзисторы, становятся тоньше =&gt; больше сопротивление</li>
                    </ul>
                </p>
            </div>

            <div class="step" data-x="3300" data-y="1600">
                <h2>Частота vs энергоэффективность</h2>
                <p>
                    <ul>
                        <li><strong>clock-gating</strong>: если новое состояние такое же, как и старое, смена не производится</li>
                        <li><strong>power-gating</strong>: неиспользуемые функциональные блоки отключаются</li>
                    </ul>
                </p>
            </div>

            <div class="step" data-y="1000" data-x="1100" data-rotate="90">
                <img src="img/boromir-on-cpus.jpg" />
            </div>

            <div class="step nested-steps" data-y="1900" data-x="1100" data-scale="3" id="mottos" data-duration="10">
                <span class="step" data-x="-100" data-y="-160" data-rotate="-20" data-scale="0.6">Параллельные алгоритмы в массы!</span>
                <span class="step" data-x="200" data-y="-10" data-rotate="10" data-scale="0.8">Нужно больше блоков исполнения!</span>
                <span class="step" data-x="10" data-y="20" data-scale="0.8">Даёшь больше нативных потоков!</span>
                <span class="step" data-x="300" data-y="200" data-rotate="30" data-scale="0.7">Не допустим простоя процессора!</span>
                <span class="step" data-x="-250" data-y="100" data-rotate="-10" data-scale="0.5">Нужно использовать модель акторов!</span>
            </div>

            <div class="step" data-x="4400">
                <h1>Cache coherency</h1>
                <p>
                    &laquo;А что, если у потоков есть общая память?&raquo;
                </p>
            </div>

            <div class="step" data-x="4400" data-y="800">
                <h2>Протокол <strong class="mono">MESI</strong></h2>
                <ul>
                    <li><span class="mono"><strong class="large">I</strong>nvalid</span> &dash; ячейка не содержится в кеше;</li>
                    <li><span class="mono"><strong class="large">S</strong>hared</span> &dash; ячейка содердится в кеше, но не только у этого ядра;</li>
                    <li><span class="mono"><strong class="large">E</strong>xclusive</span> &dash; ячейка содердится в кеше только у этого ядра;</li>
                    <li><span class="mono"><strong class="large">M</strong>odified</span> &dash; значение в кеше изменено, но об этом пока никто не знает</li>
                </ul>
            </div>

            <div class="step" data-x="4400" data-y="1600">
                <h2>Сообщения протокола <strong class="mono">MESI</strong></h2>
                <ul>
                    <li><span class="mono"><strong>Read</strong> &amp; <strong>Read Response</strong></span> &dash; чтение ячейки и ответ на этот запрос;</li>
                    <li><span class="mono"><strong>Invalidate</strong> &amp; <strong>Invalidate Acknowledge</strong></span> &dash; команда удалить ячейку из кеша и ответ на этот запрос;</li>
                    <li><span class="mono"><strong>Read Invalidate</strong></span> &dash; запрос значения ячейки с требованием еэ сразу же удалить;</li>
                    <li><span class="mono"><strong>Writeback</strong></span> &dash; записать ячейку в основную память</li>
                </ul>
            </div>

            <div class="step" data-x="4400" data-y="2400">
                <h2>Store Buffers</h2>
                <p>
                    Не дожидаясь <strong class="mono">Invalidate Acknowledge</strong>, поместить новое значение в буфер и продолжить выполнять инструкции.
                    Когда придут все <strong class="mono">acknowledge</strong>, произвести запись.
                </p>
            </div>

            <div class="step nested-steps listing" data-x="4400" data-y="3200">
                <table>
                    <tr>
                        <td style="width: 450px;"><strong class="mono">CPU 0</strong></td>
                        <td><strong class="mono">CPU 1</strong></td>
                    </tr>
                    <tr>
                        <td>
                            <pre>
value <span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
finished <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>true</span><span style='color:#800080; '>;</span></pre>
                        </td>
                        <td>
                            <pre>
<span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>finished<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<b>assert</b> value <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="100">
                        <td colspan="2">
                            Казалось бы, что может пойти не так?
                        </td>
                    </tr>
                    <tr class="step" data-y="200">
                        <td style="width: 450px;">
                            <pre>finished: <strong>E</strong>
value: <strong>I</strong></pre>
                        </td>
                        <td>
                            <pre>finished: <strong>I</strong>
value: <strong>E</strong></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="300">
                        <td style="width: 450px;">
                            <pre>&gt; value <span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
&lt; store_buffer(<strong>value</strong>)
&lt; read_inv(<strong>value</strong>)</pre>
                        </td>
                        <td valign="top">
                            <pre>&gt; <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>finished<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
&lt; read(<strong>finished</strong>)</pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="450">
                        <td style="width: 450px;">
                            <pre>&gt; finished <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>true</span><span style='color:#800080; '>;</span>
finished: <strong>M</strong>
&lt; read_resp(<strong>finished</strong>)
finished: <strong>S</strong></pre>
                        </td>
                        <td valign="top">
                            <pre>



finished: <strong>S</strong></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="600">
                        <td style="width: 450px;">
                        </td>
                        <td valign="top">
                            <pre>&gt; <b>assert</b> value <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="800">
                        <td colspan="2">
                            <center><h1 style="color: darkred">Assertion FAILS!</h1></center>
                        </td>
                    </tr>
                    <tr class="step" data-y="1000">
                        <td style="width: 450px;">
                        </td>
                        <td valign="top">
                            <pre>&lt; read_resp(<strong>value</strong>)
&lt; invalidate_ack(<strong>value</strong>)
value: <strong>I</strong>
                            </pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="1100">
                        <td style="width: 450px;">
                            <pre>&lt; writeback(<strong>value</strong>)</pre>
                        </td>
                        <td></td>
                    </tr>
                </table>
            </div>

            <div class="step" data-x="5500" data-y="2400">
                <h2>Invalidate queues</h2>
                <p>
                    <strong class="mono">Invalidate Acknowledge</strong> будет отправлен моментально, а фактически инвалидацию процессор сделает тогда, когда
                    ему это будет удобно. При этом до того, как он это сделает, не будет отправлено ни одно сообщение по соответствующей ячейке памяти.
                </p>
            </div>

            <div class="step nested-steps listing" data-x="5500" data-y="3200">
                <table>
                    <tr>
                        <td style="width: 450px;"><strong class="mono">CPU 0</strong></td>
                        <td><strong class="mono">CPU 1</strong></td>
                    </tr>
                    <tr>
                        <td>
                            <pre>
value <span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
finished <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>true</span><span style='color:#800080; '>;</span></pre>
                        </td>
                        <td>
                            <pre>
<span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>finished<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<b>assert</b> value <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="100">
                        <td colspan="2">
                            Казалось бы, что <strong>ещё</strong> может пойти не так?
                        </td>
                    </tr>
                    <tr class="step" data-y="200">
                        <td style="width: 450px;">
                            <pre>finished: <strong>E</strong>
value: <strong>S</strong></pre>
                        </td>
                        <td>
                            <pre>finished: <strong>I</strong>
value: <strong>S</strong></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="300">
                        <td style="width: 450px;">
                            <pre>&gt; value <span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
&lt; store_buffer(<strong>value</strong>)
&lt; invalidate(<strong>value</strong>)</pre>
                        </td>
                        <td valign="top">
                            <pre>&gt; <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>finished<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
&lt; read(<strong>finished</strong>)</pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="450">
                        <td style="width: 450px;">
                            <pre>&gt; finished <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>true</span><span style='color:#800080; '>;</span>
finished: <strong>M</strong>
&lt; read_resp(<strong>finished</strong>)
finished: <strong>S</strong></pre>
                        </td>
                        <td valign="top">
                            <pre>invalidate_ack(<strong>value</strong>)
invalidate_queue(<strong>value</strong>)

finished: <strong>S</strong></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="600">
                        <td style="width: 450px;">
                        </td>
                        <td valign="top">
                            <pre>&gt; <b>assert</b> value <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span></pre>
                        </td>
                    </tr>
                    <tr class="step" data-y="800">
                        <td colspan="2">
                            <center><h1 style="color: darkred">Assertion fails AGAIN!</h1></center>
                        </td>
                    </tr>
                    <tr class="step" data-y="1000">
                        <td style="width: 450px;">
                            <pre>&lt; writeback(<strong>value</strong>)</pre>
                        </td>
                        <td valign="top">
                            <pre>value: <strong>I</strong></pre>
                        </td>
                    </tr>
                </table>
            </div>

            <div class="step" data-x="5500" data-rotate="270">
                <h1>Trade-off</h1>
                <p>
                    <strong>Performance</strong> vs <strong>"free" coherence</strong>
                </p>
                <p>
                    Есть грань между производительностью и "простотой" написания многопоточного приложения
                </p>
            </div>

            <div class="step" data-x="6300" data-rotate="270">
                <h1>Memory Model</h1>
                <p>
                    Описание того, как потоки взаимодействуют с памятью в некоторой среде исполнения. Позволяет "автору" кода (разработчику, компилятору, ...)
                    понять, как их код всё же будет выполнен.
                </p>
            </div>

            <div class="step" data-x="7100" data-rotate="270">
                <h1>Memory Barrier</h1>
                <p>
                    Инструкция для процессора, запрещающая допускать <strong>reordering</strong> инструкций чтения и/или записи. В простейшем случае различают <strong>Store Memory Barrier</strong>, <strong>Load Memory Barrier</strong>, <strong>Fence</strong>
                </p>
            </div>

            <div class="step" data-x="8000" data-rotate="270">
                <h1>Store Memory Barrier</h1>
                <p>
                    Требование у процессора выполнить все <strong>store</strong>, уже находящиеся в буфере, прежде чем выполнять те, что попадут туда после этой инструкции
                </p>
            </div>

            <div class="step" data-x="8900" data-rotate="270">
                <h1>Load Memory Barrier</h1>
                <p>
                    Требование у процессора применить все <strong>invalidate</strong>, уже находящиеся в очереди, прежде чем выполнять какие-либо инструкции <strong>load</strong>
                </p>
            </div>

            <div class="step" data-x="9800" data-rotate="270">
                <table>
                    <tr>
                        <td style="width: 450px;"><strong class="mono">CPU 0</strong></td>
                        <td><strong class="mono">CPU 1</strong></td>
                    </tr>
                    <tr>
                        <td>
                            <pre>
value <span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span>
storeMemoryBarrier();
finished <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>true</span><span style='color:#800080; '>;</span></pre>
                        </td>
                        <td>
                            <pre>
<span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>!</span>finished<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
loadMemoryBarrier();
<b>assert</b> value <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>10</span><span style='color:#800080; '>;</span></pre>
                        </td>
                    </tr>
                </table>
            </div>

            <div class="step" data-x="10700" data-rotate="270">
                <h1>Membar &dash; инструмент HMM</h1>
                <p>
                    Различных HMM очень много; они варьируются не только от вендора к вендору, но даже и внутри одной линейки одного производителя.
                </p>
            </div>

            <div class="step" data-x="6600" data-y="1600">
                <center>
                    <h1 style="color: #ea2d2e;">Write Once</h1>
                    <img src="img/java-logo.png" />
                    <h1 style="color: #0074bd;">Run Anywhere</h1>
                </center>
            </div>

            <div class="step" data-x="6600" data-y="2400">
                <h2>Java Memory Model</h2>
                <p>
                    Модель памяти, не зависящая от реального железа, на котором запущена JVM.
                </p>
            </div>

            <div class="step" data-x="6600" data-y="3200">
                <h1>Отношение happens-before</h1>
                <p>
                Пусть есть поток <strong style="color: green">X</strong> и поток <strong style="color: red">Y</strong>
                (не обязательно отличающийся от потока <strong style="color: green">X</strong>).
                И пусть есть операции <strong style="color: darkgreen">A</strong>
                (выполняющаяся в потоке <strong style="color: green">X</strong>) и <strong style="color: darkred">B</strong> (выполняющаяся в потоке <strong style="color: red">Y</strong>).
                </p>
                <p>
                    В таком случае, <strong style="color: darkgreen">A</strong> <i>happens-before</i> <strong style="color: darkred">B</strong>
                    означает, что все изменения, выполненные потоком <strong style="color: green">X</strong> до момента операции <strong style="color: darkgreen">A</strong>
                    и изменения, которые повлекла эта операция, видны потоку <strong style="color: red">Y</strong> в момент выполнения операции
                    <strong style="color: darkred">B</strong> и после выполнения этой операции.
                </p>
                <h2>Отношение happens-before транзитивно</h2>
            </div>

            <div class="step" data-x="6600" data-y="4000">
                <h2><strong style="color: darkgreen">operationA</strong> <i>happens-before</i> <strong style="color: darkred">operationB</strong></h2>
                <p>
                    <img src="img/happens-before.png" />
                </p>
            </div>

            <div class="step" data-x="6600" data-y="4800">
                <h2>Где есть happens-before</h2>
                <ul>
                    <li>Освобождение (<strong>releasing</strong>) монитора <i>happens-before</i> заполучение (<strong>acquiring</strong>) того же самого монитора.</li>
                    <li>Запись в <strong>volatile</strong> переменную <i>happens-before</i> чтение из той же самой переменной.</li>
                    <li>Последнее действие в потоке <i>happens-before</i> завершение <strong>join()</strong> или <strong>isAlive()</strong> на этом потоке</li>
                    <li>Старт потока <i>happens-before</i> первое действие в этом потоке</li>
                    <li>А ещё есть <strong>final</strong>-поля, но там всё сложнее</li>
                </ul>
            </div>

            <div class="step" data-x="6600" data-y="5600">
                <h2>На одном <i>happens-before</i> далеко не уедешь</h2>
                <p>
                    <pre style="padding-left: 20px; margin-left: 20px; border-left: solid grey 2px;"><b>volatile</b> int someInt<span style='color:#555555; '>;</span>

<span style='color: #696969'>// ...</span>

someInt++<span style='color:#555555; '>;</span> <span style='color: darkred; '>// not atomic!</span></pre>
                </p>
            </div>

            <div class="step" data-x="5500" data-y="5600" data-rotate="150">
                <h1><i>happens-before</i> обеспечивает только <strong>visibility</strong></h1>
                <p>
                    Кроме того, могут быть необходимы <strong>Atomicity</strong>, <strong>Mutual Exclusion</strong>, <strong>Synchronization</strong>
                </p>
            </div>

            <div class="step" data-x="5100" data-y="4800" data-rotate="150">
                <h1>Atomicity</h1>
                <p>
                    <strong>Compare And Set (CAS, Compare And Swap)</strong> &dash; операция, неделимо проверяющая значение ячейки и, если оно
                    соответствует ожиданиям, меняет его на указанное.
                </p>
                <pre>boolean compareAndSet(Wrapper&lt;T&gt; target, T expected,
                                         T newValue) {
  <span style='color:#7f0055; font-weight:bold; '>if</span>(target.getValue().equals(expected)) {
    target.setValue(newValue);
    <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>true</span>;
  } <span style='color:#7f0055; font-weight:bold; '>else</span> {
    <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>false</span>;
  }
}</pre>
            </div>

            <div class="step" data-x="3800" data-y="4800" data-rotate="150">
                <h1>Atomicity</h1>
                <p>
                    Используйте пакет <strong>java.util.concurrent.atomic</strong>, если необходима только атомарность. Атомарные операции нативно поддерживаются
                    большинством современных процессоров.
                </p>
            </div>

            <div class="step" data-x="3800" data-y="4800" data-rotate="150" data-rotate-x="90">
                <h2>Пример с AtomicInteger</h2>
                <pre style="padding-left: 20px; margin-left: 20px; border-left: solid grey 2px;">AtomicInteger visitors = <b>new</b> AtomicInteger();
<span style='color:#3f7f59; '>//...</span>
logger.debug(<span style="color:darkgreen">"Visitor #"</span> + visitors.incrementAndGet());</pre>
                <div class="step" data-y="350">
                    <h2>Ещё пример с AtomicInteger</h2>
                    <pre style="padding-left: 20px; margin-left: 20px; border-left: solid grey 2px;">AtomicInteger masterId = <b>new</b> AtomicInteger();

if(masterId.compareAndSet(<b>NO_MASTER</b>, myId)) {
  logger.info(<span style="color:darkgreen">"I am the master, performing operation"</span>);
  performOperation();
} else {
  logger.info(<span style="color:darkgreen">"Other master detected"</span>);
}</pre>
                </div>
            </div>

            <div class="step" data-x="3200" data-y="4100" data-rotate="150">
                <h1>Mutual Exclusion</h1>
                <p>
                    Исключение влияния потоков друг на друга. В критической секции в один момент времени может находиться лишь один поток.
                    Следует использовать, если поток должен изменить несколько значений, и между этими изменениями состояние системы неконсистентно.
                </p>
            </div>

            <div class="step" data-x="2600" data-y="3600" data-rotate="150">
                <h1>Mutual Exclusion: основные инструменты</h1>
                <ul>
                    <li>Пакет <strong>java.util.concurrent.locks</strong></li>
                    <li>Ключевое слово <strong>synchronized</strong></li>
                </ul>
            </div>

            <div class="step" data-x="2600" data-y="3600" data-rotate="150" data-rotate-x="90">
                <h2>Пример с synchronized</h2>
                <pre style="padding-left: 20px; margin-left: 20px; border-left: solid grey 2px;">
<b>synchronized</b>(this) {
  lastUserId = user.id;
  lastAction = currentAction;
}</pre>
                <div class="step" data-y="400">
                    <h2>Пример с ReentrantLock</h2>
                    <pre style="padding-left: 20px; margin-left: 20px; border-left: solid grey 2px;">ReentrantLock lock = new ReentrantLock();

<span style='color:#3f7f59; '>//...</span>

lock.lock();

try {
  lastUserId = user.id;
  lastAction = currentAction;
} finally {
  lock.unlock();
}</pre>
                </div>
            </div>

            <div class="step" data-x="2600" data-y="3600" data-rotate="150" data-rotate-x="90" data-rotate-y="90">
                <h2>synchronized vs ReentrantLock</h2>
                <ul>
                    <li>Семантика одинакова</li>
                    <li>synchronized &dash; unfair, ReentrantLock может быть fair</li>
                    <li>ReentrantLock не имеет скопов, требует unlock в finally</li>
                </ul>
                <img class="step" data-y="800" src="img/locks-1.png" />
                <img class="step" data-y="1600" src="img/locks-2.png" />
                <p class="step" data-y="2300">
                    &copy; Java Platform Performance BoF <br /> by Aleksey Shipilev and Sergey Kuksenko <br />
                    <a href="http://shipilev.net/pub/talks/javatechday-Feb2011-performanceBoF.pdf">http://shipilev.net/pub/talks/javatechday-Feb2011-performanceBoF.pdf</a>
                </p>
            </div>

            <div class="step" data-x="2100" data-y="3100" data-rotate="150">
                <h1>Synchronization</h1>
                <p>
                    Согласованность очерёдности действий потоков. Например, поток-вычислитель не может ничего вычислить, пока не подгрузилась в фоне свежая порция данных.
                </p>
            </div>

            <div class="step" data-x="2100" data-y="5500" data-rotate="150">
                <h1>Synchronization: основные инструменты</h1>
                <ul>
                    <li>Многое из пакета <strong>java.util.concurrent</strong>: <strong>Phaser</strong>, <strong>Semaphore</strong>, <strong>CountDownLatch</strong>, ...</li>
                    <li><strong>wait</strong> и <strong>notify</strong></li>
                    <li>Ключевое слово <strong>synchronized</strong></li>
                </ul>
            </div>

            <div class="step" data-x="1200" data-y="6000" data-rotate="150">
                <h1>Ещё полезные инструменты</h1>
                <ul>
                    <li>Thread Management: <strong>j.u.c.Executors</strong></li>
                    <li>Concurrent Queues: <strong>j.u.c.ConcurrentLinkedQueue</strong>, <strong>j.u.c.LinkedBlockingQueue</strong></li>
                    <li>Concurrent Collections: <strong>j.u.c.ConcurrentHashMap</strong>, <strong>j.u.c.CopyOnWriteArrayList</strong></li>
                </ul>
            </div>

            <div class="step" data-y="3000">
                <h1>Полезно почитать:</h1>
                <ul>
                    <li><a href="http://habrahabr.ru/post/133981/">http://habrahabr.ru/post/133981/</a>: Java Memory Model</li>
                    <li>Java Concurrency in Practice</li>
                    <li><a href="http://habrahabr.ru/post/143237/">http://habrahabr.ru/post/143237/</a>: Java Threading</li>
                    <li><a href="http://habrahabr.ru/post/143390/">http://habrahabr.ru/post/143390/</a>: Java Safe Publishing</li>
                    <li><a href="http://cheremin.blogspot.ru/">http://cheremin.blogspot.ru/</a>: Блог о многопоточности</li>
                </ul>
            </div>

            <div id="overview" class="step" data-x="3000" data-y="1500" data-scale="10"></div>
        </div>

        <script type="text/javascript">
            $(function() {
                    $('#impress').jmpress({
                        "mouse": { clickSelects: false },
                        "beforeChange": function(element, eventData) {
                            element = $(element);
                            if(element.is('tr')) {
                                element.addClass('visited'); // code should not be hidden after visiting
                            }
                        }
                    });
            });
        </script>
    </body>
</html>




